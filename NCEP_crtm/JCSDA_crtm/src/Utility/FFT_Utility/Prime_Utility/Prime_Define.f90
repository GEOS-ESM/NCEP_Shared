!
! Prime_Define
!
! Module defining the Prime data structure and containing routines to 
! manipulate it.
!
! CREATION HISTORY:
!       This file was initially automatically generated so edit at your own risk.
!       Generated by fdefmod.rb on 01-Dec-2006 at 12:56:14
!       Contact info:  Paul van Delst, CIMSS/SSEC
!                      paul.vandelst@ssec.wisc.edu
!

MODULE Prime_Define

  ! ------------------
  ! Environment set up
  ! ------------------
  ! Module use
  USE Message_Handler, ONLY: SUCCESS, FAILURE, Display_Message
  ! Disable implicit typing
  IMPLICIT NONE


  ! ------------
  ! Visibilities
  ! ------------
  ! Everything private by default
  PRIVATE
  ! Prime data structure definition
  PUBLIC :: Prime_type
  ! Structure procedures
  PUBLIC :: Associated_Prime
  PUBLIC :: Destroy_Prime
  PUBLIC :: Allocate_Prime
  PUBLIC :: Assign_Prime
  PUBLIC :: Equal_Prime
  PUBLIC :: Info_Prime
    

  ! -----------------
  ! Module parameters
  ! -----------------
  ! RCS Id for the module
  CHARACTER(*), PARAMETER :: MODULE_RCS_ID = &


  ! -----------------------
  ! Derived type definition
  ! -----------------------
  TYPE :: Prime_type
    INTEGER :: n_Allocates=0
    ! Dimensions
    INTEGER :: nPrimes=0
    ! Scalars
    INTEGER :: number = 0 ! Number used as input to generation/factorisation routines
    ! Arrays
    INTEGER, DIMENSION(:), POINTER :: n   =>NULL() ! Prime numbers
    INTEGER, DIMENSION(:), POINTER :: nExp=>NULL() ! Prime number exponents (for factorisation)
  END TYPE Prime_type


CONTAINS


!##################################################################################
!##################################################################################
!##                                                                              ##
!##                          ## PRIVATE MODULE ROUTINES ##                       ##
!##                                                                              ##
!##################################################################################
!##################################################################################

  SUBROUTINE Clear_Prime(Prime)
    TYPE(Prime_type), INTENT(IN OUT) :: Prime
    ! Dimensions
    Prime%nPrimes=0
    ! Scalars
    Prime%number=0
  END SUBROUTINE Clear_Prime



!##################################################################################
!##################################################################################
!##                                                                              ##
!##                           ## PUBLIC MODULE ROUTINES ##                       ##
!##                                                                              ##
!##################################################################################
!##################################################################################

  FUNCTION Associated_Prime( &
             Prime, &  ! Input
             ANY_Test ) & ! Optional input
           RESULT(Association_Status)
    ! Arguments
    TYPE(Prime_type), INTENT(IN) :: Prime
    INTEGER, OPTIONAL, INTENT(IN) :: ANY_Test
    ! Function result
    LOGICAL :: Association_Status
    ! Local variables
    LOGICAL :: ALL_Test
    
    ! Default is to test ALL the pointer members
    ! for a true association status....
    ALL_Test = .TRUE.
    ! ...unless the ANY_Test argument is set.
    IF ( PRESENT( ANY_Test ) ) THEN
      IF ( ANY_Test == 1 ) ALL_Test = .FALSE.
    END IF
    
    ! Test the structure associations    
    Association_Status = .FALSE.
    IF (ALL_Test) THEN
      IF ( ASSOCIATED(Prime%n   ) .AND. &
           ASSOCIATED(Prime%nExp) ) THEN
        Association_Status = .TRUE.
      END IF
    ELSE
      IF ( ASSOCIATED(Prime%n   ) .OR. &
           ASSOCIATED(Prime%nExp) ) THEN
        Association_Status = .TRUE.
      END IF
    END IF
    
  END FUNCTION Associated_Prime


  FUNCTION Destroy_Prime( &
             Prime, &  ! Output
             No_Clear, &  ! Optional input
             RCS_Id, &  ! Revision control
             Message_Log ) &  ! Error messaging
           RESULT(Error_Status)
    ! Arguments
    TYPE(Prime_type), INTENT(IN OUT) :: Prime 
    INTEGER,      OPTIONAL, INTENT(IN)  :: No_Clear
    CHARACTER(*), OPTIONAL, INTENT(OUT) :: RCS_Id
    CHARACTER(*), OPTIONAL, INTENT(IN)  :: Message_Log
    ! Function result
    INTEGER :: Error_Status
    ! Local parameters
    CHARACTER(*), PARAMETER :: ROUTINE_NAME = 'Destroy_Prime'
    ! Local variables
    CHARACTER(256)  :: Message
    LOGICAL :: Clear
    INTEGER :: Allocate_Status
    
    ! Set up
    Error_Status = SUCCESS
    IF ( PRESENT( RCS_Id ) ) RCS_Id = MODULE_RCS_ID
    
    ! Default is to clear scalar members...
    Clear = .TRUE.
    ! ....unless the No_Clear argument is set
    IF ( PRESENT( No_Clear ) ) THEN
      IF ( No_Clear == 1 ) Clear = .FALSE.
    END IF
    
    ! Initialise the scalar members
    IF ( Clear ) CALL Clear_Prime(Prime)
    
    ! If ALL pointer members are NOT associated, do nothing
    IF ( .NOT. Associated_Prime(Prime) ) RETURN
    
    ! Deallocate the pointer members
    DEALLOCATE( Prime%n   , &
                Prime%nExp, &
                STAT = Allocate_Status )
    IF ( Allocate_Status /= 0 ) THEN
      WRITE( Message, '( "Error deallocating Prime. STAT = ", i5 )' ) &
                      Allocate_Status
      Error_Status = FAILURE
      CALL Display_Message( &
             ROUTINE_NAME, &
             TRIM(Message), &
             Error_Status, &
             Message_Log=Message_Log )
      RETURN
    END IF
    
    ! Decrement and test allocation counter
    Prime%n_Allocates = Prime%n_Allocates - 1
    IF ( Prime%n_Allocates /= 0 ) THEN
      WRITE( Message, '( "Allocation counter /= 0, Value = ", i5 )' ) &
                      Prime%n_Allocates
      Error_Status = FAILURE
      CALL Display_Message( &
             ROUTINE_NAME, &
             TRIM(Message), &
             Error_Status, &
             Message_Log=Message_Log )
      RETURN
    END IF
    
  END FUNCTION Destroy_Prime


  FUNCTION Allocate_Prime( &
             nPrimes, &  ! Input
             Prime, &  ! Output
             RCS_Id,       &  ! Revision control
             Message_Log ) &  ! Error messaging
           RESULT( Error_Status )
    ! Arguments
    INTEGER, INTENT(IN) :: nPrimes
    TYPE(Prime_type), INTENT(IN OUT) :: Prime
    CHARACTER(*), OPTIONAL, INTENT(OUT) :: RCS_Id
    CHARACTER(*), OPTIONAL, INTENT(IN)  :: Message_Log
    ! Function result
    INTEGER :: Error_Status
    ! Local parameters
    CHARACTER(*), PARAMETER :: ROUTINE_NAME = 'Allocate_Prime'
    ! Local variables
    CHARACTER(256)  :: Message
    INTEGER :: Allocate_Status
    
    ! Set up
    Error_Status = SUCCESS
    IF ( PRESENT( RCS_Id ) ) RCS_Id = MODULE_RCS_ID
    
    ! Check dimensions
    IF ( nPrimes < 1 .OR. &
         nPrimes < 1 ) THEN
      Error_Status = FAILURE
      CALL Display_Message( &
             ROUTINE_NAME, &
             'Input Prime dimensions must all be > 0.', &
             Error_Status, &
             Message_Log=Message_Log )
      RETURN
    END IF
    
    ! Check if ANY pointers are already associated.
    ! If they are, deallocate them but leave scalars.
    IF ( Associated_Prime( Prime, ANY_Test=1 ) ) THEN
      Error_Status = Destroy_Prime( &
                       Prime, &
                       No_Clear=1, &
                       Message_Log=Message_Log )
      IF ( Error_Status /= SUCCESS ) THEN
        Error_Status = FAILURE
        CALL Display_Message( &
               ROUTINE_NAME, &
               'Error deallocating Prime prior to allocation.', &
               Error_Status, &
               Message_Log=Message_Log )
        RETURN
      END IF
    END IF
    
    ! Perform the pointer allocation
    ALLOCATE( Prime%n(nPrimes), &
              Prime%nExp(nPrimes), &
              STAT = Allocate_Status )
    IF ( Allocate_Status /= 0 ) THEN
      WRITE( Message, '( "Error allocating Prime data arrays. STAT = ", i5 )' ) &
                      Allocate_Status
      Error_Status = FAILURE
      CALL Display_Message( &
             ROUTINE_NAME, &
             TRIM(Message), &
             Error_Status, &
             Message_Log=Message_Log )
      RETURN
    END IF
    
    ! Assign the dimensions
    Prime%nPrimes = nPrimes

    ! Initialise the arrays
    Prime%n    = 0
    Prime%nExp = 1

    ! Increment and test the allocation counter
    Prime%n_Allocates = Prime%n_Allocates + 1
    IF ( Prime%n_Allocates /= 1 ) THEN
      WRITE( Message, '( "Allocation counter /= 1, Value = ", i5 )' ) &
                      Prime%n_Allocates
      Error_Status = FAILURE
      CALL Display_Message( &
             ROUTINE_NAME, &
             TRIM(Message), &
             Error_Status, &
             Message_Log=Message_Log )
      RETURN
    END IF
    
  END FUNCTION Allocate_Prime


  FUNCTION Assign_Prime( &
             Prime_in , &  ! Input
             Prime_out, &  ! Output
             RCS_Id      , &  ! Revision control
             Message_Log ) &  ! Error messaging
           RESULT( Error_Status )
    ! Arguments
    TYPE(Prime_type), INTENT(IN)     :: Prime_in
    TYPE(Prime_type), INTENT(IN OUT) :: Prime_out
    CHARACTER(*), OPTIONAL, INTENT(OUT) :: RCS_Id
    CHARACTER(*), OPTIONAL, INTENT(IN)  :: Message_Log
    ! Function result
    INTEGER :: Error_Status
    ! Local parameters
    CHARACTER(*), PARAMETER :: ROUTINE_NAME = 'Assign_Prime'
    ! Local variables
    INTEGER :: i1
    
    ! Set up
    IF ( PRESENT( RCS_Id ) ) RCS_Id = MODULE_RCS_ID
    
    ! ALL *input* pointers must be associated
    IF ( .NOT. Associated_Prime(Prime_In) ) THEN
      Error_Status = FAILURE
      CALL Display_Message( &
             ROUTINE_NAME, &
             'Some or all INPUT Prime pointer members are NOT associated.', &
             Error_Status, &
             Message_Log=Message_Log )
      RETURN
    END IF
    
    ! Allocate data arrays
    Error_Status = Allocate_Prime( &
                     Prime_in%nPrimes, &
                     Prime_out, &
                     Message_Log=Message_Log)
    IF ( Error_Status /= SUCCESS ) THEN
      Error_Status = FAILURE
      CALL Display_Message( &
             ROUTINE_NAME, &
             'Error allocating output structure', &
             Error_Status, &
             Message_Log=Message_Log )
      RETURN
    END IF
    
    ! Assign non-dimension scalar members
    Prime_out%number = Prime_in%number

    ! Copy array data
    Prime_out%n    = Prime_in%n
    Prime_out%nExp = Prime_in%nExp

  END FUNCTION Assign_Prime


  FUNCTION Equal_Prime( &
             Prime_LHS, &  ! Input
             Prime_RHS, &  ! Input
             ULP_Scale,    &  ! Optional input
             RCS_Id,       &  ! Revision control
             Message_Log ) &  ! Error messaging
           RESULT( Error_Status )
    ! Arguments
    TYPE(Prime_type), INTENT(IN)  :: Prime_LHS
    TYPE(Prime_type), INTENT(IN)  :: Prime_RHS
    INTEGER,      OPTIONAL, INTENT(IN)  :: ULP_Scale
    CHARACTER(*), OPTIONAL, INTENT(OUT) :: RCS_Id
    CHARACTER(*), OPTIONAL, INTENT(IN)  :: Message_Log
    ! Function result
    INTEGER :: Error_Status
    ! Local parameters
    CHARACTER(*), PARAMETER :: ROUTINE_NAME = 'Equal_Prime'
    ! Local variables
    CHARACTER(256)  :: Message
    INTEGER :: ULP
    INTEGER :: l, j
    INTEGER :: i1
    
    ! Set up
    Error_Status = SUCCESS
    IF ( PRESENT( RCS_Id ) ) RCS_Id = MODULE_RCS_ID
    
    ! Default precision is a single unit in last place
    ULP = 1
    ! ... unless the ULP_Scale argument is set and positive
    IF ( PRESENT( ULP_Scale ) ) THEN
      IF ( ULP_Scale > 0 ) ULP = ULP_Scale
    END IF
    
    ! Check the structure association status
    IF ( .NOT. Associated_Prime( Prime_LHS ) ) THEN
      Error_Status = FAILURE
      CALL Display_Message( &
             ROUTINE_NAME, &
             'Some or all INPUT Prime_LHS pointer members are NOT associated.', &
             Error_Status, &
             Message_Log=Message_Log )
      RETURN
    END IF
    IF ( .NOT. Associated_Prime( Prime_RHS ) ) THEN
      Error_Status = FAILURE
      CALL Display_Message( &
             ROUTINE_NAME, &
             'Some or all INPUT Prime_RHS pointer members are NOT associated.', &
             Error_Status, &
             Message_Log=Message_Log )
      RETURN
    END IF
    
    ! Check dimensions
    IF ( Prime_LHS%nPrimes /= Prime_RHS%nPrimes .OR. &
         Prime_LHS%nPrimes /= Prime_RHS%nPrimes ) THEN
      Error_Status = FAILURE
      CALL Display_Message( &
             ROUTINE_NAME, &
             'Structure dimensions are different.', &
             Error_Status, &
             Message_Log=Message_Log )
      RETURN
    END IF
    
    ! Check the scalar components
    IF( Prime_LHS%number /= Prime_RHS%number) THEN
      Error_Status = FAILURE
      CALL Display_Message( &
             ROUTINE_NAME, &
             'Prime scalar component number values are different.', &
             Error_Status, &
             Message_Log=Message_Log )
      RETURN
    END IF

    ! Check the array components
    IF ( ANY( Prime_LHS%n /= Prime_RHS%n ) ) THEN
      Error_Status = FAILURE
      CALL Display_Message( &
             ROUTINE_NAME, &
             'Prime array component n values are different.', &
             Error_Status, &
             Message_Log=Message_Log )
      RETURN
    END IF
    IF ( ANY( Prime_LHS%nExp /= Prime_RHS%nExp ) ) THEN
      Error_Status = FAILURE
      CALL Display_Message( &
             ROUTINE_NAME, &
             'Prime array component nExp values are different.', &
             Error_Status, &
             Message_Log=Message_Log )
      RETURN
    END IF

  END FUNCTION Equal_Prime


  SUBROUTINE Info_Prime( &
               Prime, &
               Info,     &  ! Output
               RCS_Id    )  ! Revision control
    ! Arguments
    TYPE(Prime_type),    INTENT(IN)  :: Prime
    CHARACTER(*),           INTENT(OUT) :: Info
    CHARACTER(*), OPTIONAL, INTENT(OUT) :: RCS_Id
    ! Parameters
    INTEGER, PARAMETER :: CARRIAGE_RETURN = 13
    INTEGER, PARAMETER :: LINEFEED = 10
    ! Local variables
    CHARACTER(80)  :: FmtString
    CHARACTER(512) :: LongString
    
    ! Set up
    IF ( PRESENT( RCS_Id ) ) RCS_Id = MODULE_RCS_ID
    
    ! Write the required info to the local string
    FmtString='(a,1x,"Prime:",2x,&
                &"NPRIMES=",i0,2x,&
                &)'
    WRITE( LongString, FMT=FmtString ) &
      ACHAR(CARRIAGE_RETURN)//ACHAR(LINEFEED), &
      Prime%nPrimes
    
    ! Trim the output based on the
    ! dummy argument string length
    Info = LongString(1:MIN( LEN(Info), LEN_TRIM( LongString ) ))
    
  END SUBROUTINE Info_Prime

END MODULE Prime_Define
